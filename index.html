<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Frozen Christmas Tree</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
    
    <script src="https://unpkg.com/@babel/standalone@7.24.0/babel.min.js"></script>

    <style>
      body {
        background-color: #020210;
        font-family: 'Cinzel', serif;
      }
      .font-great-vibes {
        font-family: 'Great Vibes', cursive;
      }
      .text-glow {
        text-shadow: 0 0 30px rgba(136, 204, 255, 0.8), 0 0 60px rgba(204, 255, 255, 0.4);
      }
      .text-glow-hover:hover {
        text-shadow: 0 0 50px rgba(136, 204, 255, 1.0), 0 0 80px rgba(255, 255, 255, 0.8);
      }
      .spinner {
        animation: spin 1s linear infinite;
      }
      @keyframes spin { 
        0% { transform: rotate(0deg); } 
        100% { transform: rotate(360deg); } 
      }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.3.1",
        "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        // --- CONSTANTS ---
        const CONFIG = {
            colors: { bg: 0x020210, iceBlue: 0x88ccff, cyan: 0xccffff, white: 0xffffff, silver: 0xaaaaaa, stream: 0xffffff },
            particles: { count: 1500, dustCount: 2000, treeHeight: 24, treeRadius: 8 },
            camera: { z: 50, zScatter: 80 },
            photos: { count: 12 }
        };

        const InteractionMode = { TREE: 'TREE', SCATTER: 'SCATTER', FOCUS: 'FOCUS' };

        // --- UPDATED HAND GESTURE LOGIC ONLY ---
        const useMediaPipe = ({ videoRef, canvasRef, onGestureChange, onLoaded }) => {
            const handLandmarkerRef = useRef(null);
            const lastVideoTimeRef = useRef(-1);
            const animationFrameId = useRef(undefined);
            const handPositionRef = useRef({ x: 0, y: 0 });
            const isHandDetectedRef = useRef(false);
            const [isInitialized, setIsInitialized] = useState(false);

            const predictWebcam = useCallback(async () => {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                const handLandmarker = handLandmarkerRef.current;
                
                if (!video || !canvas || !handLandmarker || video.readyState < 2) {
                    animationFrameId.current = requestAnimationFrame(predictWebcam);
                    return;
                }

                if (video.currentTime !== lastVideoTimeRef.current) {
                    lastVideoTimeRef.current = video.currentTime;
                    const results = handLandmarker.detectForVideo(video, performance.now());
                    
                    const ctx = canvas.getContext('2d');
                    if (ctx && video.videoWidth > 0) {
                        ctx.save();
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.scale(-1, 1);
                        ctx.translate(-canvas.width, 0);
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        if (results.landmarks) {
                            const drawingUtils = new DrawingUtils(ctx);
                            for (const landmarks of results.landmarks) {
                                drawingUtils.drawLandmarks(landmarks, { color: '#00ffff', lineWidth: 1, radius: 2 });
                                drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: '#ccffff', lineWidth: 1 });
                            }
                        }
                        ctx.restore();
                    }

                    if (results.landmarks && results.landmarks.length > 0) {
                        isHandDetectedRef.current = true;
                        const lm = results.landmarks[0];
                        
                        // Normalized metrics
                        const wrist = lm[0];
                        const middleMcp = lm[9];
                        const handScale = Math.max(0.01, Math.hypot(wrist.x - middleMcp.x, wrist.y - middleMcp.y));
                        
                        // Gesture Distances
                        const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) / handScale;
                        const fingerTips = [8, 12, 16, 20];
                        let avgTipDist = 0;
                        fingerTips.forEach(idx => avgTipDist += Math.hypot(lm[idx].x - middleMcp.x, lm[idx].y - middleMcp.y));
                        const openness = (avgTipDist / 4) / handScale;

                        handPositionRef.current = { x: (lm[9].x - 0.5) * 2, y: (lm[9].y - 0.5) * 2 };

                        // --- THE GESTURE COMMANDS ---
                        if (openness > 1.8) {
                            onGestureChange(InteractionMode.SCATTER, true); // Âº†ÂºÄÊâãÊéå -> Âº•Êï£
                        } else if (pinchDist < 0.6) {
                            onGestureChange(InteractionMode.FOCUS, true);   // ‰∫îÊåáÊçèÂêà -> ÊîæÂ§ßÁÖßÁâá
                        } else if (openness < 0.9) {
                            onGestureChange(InteractionMode.TREE, true);    // Êè°Êã≥ -> ËøòÂéüÂú£ËØûÊ†ë
                        }
                    } else {
                        isHandDetectedRef.current = false;
                        onGestureChange(InteractionMode.TREE, false);
                    }
                }
                animationFrameId.current = requestAnimationFrame(predictWebcam);
            }, [onGestureChange]);

            useEffect(() => {
                const initialize = async () => {
                    try {
                        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
                        const modelPath = "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task";
                        handLandmarkerRef.current = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: { modelAssetPath: modelPath, delegate: "GPU" },
                            runningMode: "VIDEO", numHands: 1
                        });
                        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240 } });
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.onloadeddata = () => {
                                if (canvasRef.current) {
                                    canvasRef.current.width = videoRef.current.videoWidth;
                                    canvasRef.current.height = videoRef.current.videoHeight;
                                }
                                setIsInitialized(true);
                                onLoaded();
                            };
                        }
                    } catch (error) { console.error(error); }
                };
                initialize();
                return () => animationFrameId.current && cancelAnimationFrame(animationFrameId.current);
            }, []);

            useEffect(() => { if (isInitialized) animationFrameId.current = requestAnimationFrame(predictWebcam); }, [isInitialized, predictWebcam]);
            return { gestureManager: { isHandDetected: () => isHandDetectedRef.current, getHandPosition: () => handPositionRef.current } };
        };

        // --- FULL SCENE CONTROLLER (PRESERVING YOUR BEAUTIFUL TREE) ---
        class SceneController {
            constructor(container, onModeChangeRequest) {
                this.onModeChangeRequest = onModeChangeRequest;
                this.mainGroup = new THREE.Group();
                this.photoGroup = new THREE.Group();
                this.clock = new THREE.Clock();
                this.particles = [];
                this.dusts = [];
                this.photos = [];
                this.instancedMeshes = {};
                this.spiralMesh = null;
                this.focusTarget = null;
                this.dummy = new THREE.Object3D();
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.state = { rotation: { x: 0, y: 0 } };

                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                container.appendChild(this.renderer.domElement);
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                this.renderer.toneMappingExposure = 2.0;
                this.camera.position.set(0, 2, CONFIG.camera.z);
                this.scene.background = new THREE.Color(CONFIG.colors.bg);
                this.scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.015);
                this.scene.add(this.mainGroup);
                this.mainGroup.add(this.photoGroup);

                const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
                this.scene.environment = pmremGenerator.fromScene(new RoomEnvironment(this.renderer), 0.04).texture;
                pmremGenerator.dispose();

                this.init();
            }

            init() {
                this.scene.add(new THREE.AmbientLight(0xccddff, 0.4));
                const innerLight = new THREE.PointLight(CONFIG.colors.iceBlue, 2, 25); innerLight.position.set(0, 5, 0);
                this.mainGroup.add(innerLight);

                // Particles
                const geometries = { ICE: new THREE.IcosahedronGeometry(0.4, 0), SNOW: new THREE.SphereGeometry(0.4, 8, 8), FLAKE: new THREE.PlaneGeometry(0.8, 0.8), GLOW: new THREE.IcosahedronGeometry(0.3, 0) };
                const materials = { 
                    ICE: new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.iceBlue, metalness: 0.1, roughness: 0.1, transmission: 0.9, thickness: 1.0, ior: 1.5, envMapIntensity: 2.0, clearcoat: 1.0 }), 
                    SNOW: new THREE.MeshStandardMaterial({ color: CONFIG.colors.white, metalness: 0.1, roughness: 0.9, emissive: 0x222222 }), 
                    FLAKE: new THREE.MeshBasicMaterial({ transparent: true, opacity: 0.9, side: THREE.DoubleSide, color: CONFIG.colors.cyan }), 
                    GLOW: new THREE.MeshBasicMaterial({ color: CONFIG.colors.cyan, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending }) 
                };
                
                const counts = { ICE: 600, SNOW: 400, FLAKE: 300, GLOW: 200 };
                Object.keys(counts).forEach(key => {
                    const mesh = new THREE.InstancedMesh(geometries[key], materials[key], counts[key]);
                    this.instancedMeshes[key] = mesh;
                    this.mainGroup.add(mesh);
                });

                let pIdx = 0;
                Object.keys(counts).forEach(type => {
                    for(let i=0; i<counts[type]; i++) {
                        const h = CONFIG.particles.treeHeight; let t = Math.pow(Math.random(), 0.8);
                        const y = (t * h) - (h / 2); let rMax = CONFIG.particles.treeRadius * (1.0 - t) || 0.5;
                        const angle = t * 50 * Math.PI + Math.random() * Math.PI; const r = rMax * (0.8 + Math.random() * 0.4);
                        const posTree = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                        const rS = 15 + Math.random() * 25; const phi = Math.acos(2 * Math.random() - 1); const theta = Math.random() * Math.PI * 2;
                        const posScatter = new THREE.Vector3(rS * Math.sin(phi) * Math.cos(theta), rS * Math.cos(phi), rS * Math.sin(phi) * Math.sin(theta));
                        this.particles.push({ type, index: i, meshRef: this.instancedMeshes[type], posTree, posScatter, currentPos: posTree.clone(), scale: 0.4 + Math.random() * 0.5 });
                    }
                });

                // Ribbon
                const points = []; for (let i = 0; i <= 200; i++) { const t = i / 200; const angle = t * Math.PI * 10; const y = (t * 24) - 12; points.push(new THREE.Vector3(Math.cos(angle) * (10*(1-t)), y, Math.sin(angle) * (10*(1-t)))); }
                this.spiralMesh = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 200, 0.06, 6, false), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.95 }));
                this.mainGroup.add(this.spiralMesh);

                this.createDefaultPhotos();
                
                const renderScene = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.35, 0.8, 0.85);
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(bloomPass);
            }

            createDefaultPhotos() {
                for (let i = 0; i < 8; i++) {
                    const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 256; const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#1a1a2a'; ctx.fillRect(0,0,256,256); ctx.strokeStyle = '#88ccff'; ctx.lineWidth = 10; ctx.strokeRect(10,10,236,236);
                    const texture = new THREE.CanvasTexture(canvas);
                    const group = new THREE.Group();
                    group.add(new THREE.Mesh(new THREE.BoxGeometry(1.3, 1.3, 0.05), new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9 })));
                    const photo = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), new THREE.MeshBasicMaterial({ map: texture })); photo.position.z = 0.04;
                    group.add(photo); group.scale.setScalar(4);
                    const angle = (i / 8) * Math.PI * 2; group.position.set(Math.cos(angle) * 15, (Math.random()-0.5)*10, Math.sin(angle) * 15);
                    this.photoGroup.add(group); this.photos.push({ mesh: group, origPos: group.position.clone() });
                }
            }

            animate(mode, gm) {
                const dt = this.clock.getDelta();
                const targetZ = mode === InteractionMode.SCATTER ? 85 : 50;
                this.camera.position.z = THREE.MathUtils.lerp(this.camera.position.z, targetZ, 0.05);

                if (mode === InteractionMode.SCATTER && gm.isHandDetected()) {
                    const hP = gm.getHandPosition();
                    this.state.rotation.y = THREE.MathUtils.lerp(this.state.rotation.y, hP.x * Math.PI, 0.1);
                    this.state.rotation.x = THREE.MathUtils.lerp(this.state.rotation.x, hP.y * Math.PI * 0.5, 0.1);
                } else {
                    this.state.rotation.y += 0.5 * dt;
                    this.state.rotation.x = THREE.MathUtils.lerp(this.state.rotation.x, 0, 0.05);
                }
                this.mainGroup.rotation.set(this.state.rotation.x, this.state.rotation.y, 0);

                this.particles.forEach(p => {
                    const target = mode === InteractionMode.SCATTER ? p.posScatter : p.posTree;
                    p.currentPos.lerp(target, 0.1);
                    this.dummy.position.copy(p.currentPos); this.dummy.scale.setScalar(p.scale); this.dummy.updateMatrix();
                    p.meshRef.setMatrixAt(p.index, this.dummy.matrix);
                });
                Object.values(this.instancedMeshes).forEach(m => m.instanceMatrix.needsUpdate = true);

                if (mode === InteractionMode.FOCUS) {
                   this.photoGroup.children.forEach(p => {
                       p.position.lerp(new THREE.Vector3(0, 0, 30).applyMatrix4(this.mainGroup.matrixWorld.clone().invert()), 0.1);
                       p.lookAt(this.camera.position);
                   });
                } else {
                   this.photos.forEach(p => p.mesh.position.lerp(p.origPos, 0.1));
                }
                this.composer.render();
            }
            resize(w, h) { this.camera.aspect = w/h; this.camera.updateProjectionMatrix(); this.renderer.setSize(w,h); this.composer.setSize(w,h); }
        }

        // --- COMPONENTS ---
        const App = () => {
            const [isLoading, setIsLoading] = useState(true);
            const [mode, setMode] = useState(InteractionMode.TREE);
            const [handDetected, setHandDetected] = useState(false);
            const vRef = useRef(null); const cRef = useRef(null); const containerRef = useRef(null); const sceneCtrl = useRef(null);

            const { gestureManager } = useMediaPipe({ videoRef: vRef, canvasRef: cRef, onGestureChange: (m, d) => { setMode(m); setHandDetected(d); }, onLoaded: () => setIsLoading(false) });

            useEffect(() => {
                if (!containerRef.current) return;
                sceneCtrl.current = new SceneController(containerRef.current, setMode);
                const loop = () => { sceneCtrl.current.animate(mode, gestureManager); requestAnimationFrame(loop); };
                const onResize = () => sceneCtrl.current.resize(containerRef.current.clientWidth, containerRef.current.clientHeight);
                window.addEventListener('resize', onResize);
                loop();
                return () => window.removeEventListener('resize', onResize);
            }, [gestureManager, mode]);

            return (
                <div className="relative w-screen h-screen overflow-hidden bg-black">
                    {isLoading && (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-[#020210]">
                            <div className="spinner w-12 h-12 border-4 border-cyan-500 border-t-transparent rounded-full"></div>
                            <p className="mt-4 text-cyan-300 tracking-widest font-thin">SUMMONING WINTER MAGIC...</p>
                        </div>
                    )}
                    <div ref={containerRef} className="w-full h-full" />
                    <div className="absolute top-10 w-full text-center pointer-events-none">
                        <h1 className="text-6xl md:text-8xl font-great-vibes text-glow bg-gradient-to-b from-white to-cyan-300 bg-clip-text text-transparent">Frozen Tree</h1>
                        <div className="mt-4 flex flex-col items-center">
                             <p className="text-cyan-400 tracking-[0.3em] uppercase text-sm">{handDetected ? `Status: ${mode}` : "Raise Hand to start"}</p>
                             <div className="mt-2 text-[10px] text-cyan-500/60 flex gap-4">
                                <span>‚úã OPEN: SCATTER</span><span>ü§è PINCH: FOCUS</span><span>‚úä FIST: RESET TREE</span>
                             </div>
                        </div>
                    </div>
                    <div className="absolute bottom-10 right-10 w-48 h-36 border border-cyan-500/30 rounded-lg overflow-hidden bg-black/50 backdrop-blur-md">
                        <video ref={vRef} autoPlay playsInline className="hidden"></video>
                        <canvas id="preview-canvas" ref={cRef} className="w-full h-full object-cover"></canvas>
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
