<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frozen Wonderland - Rendering Fix</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@babel/standalone@7.24.0/babel.min.js"></script>

    <style>
      body { background-color: #020210; margin: 0; overflow: hidden; }
      .font-great-vibes { font-family: 'Great Vibes', cursive; }
      .text-glow { text-shadow: 0 0 30px rgba(136, 204, 255, 0.8); }
      .spinner { animation: spin 1s linear infinite; }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
      #preview-canvas { transform: scaleX(-1); border: 1px solid #00ffff; border-radius: 4px; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.3.1",
        "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect, useCallback } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        const InteractionMode = { TREE: 'TREE', SCATTER: 'SCATTER', FOCUS: 'FOCUS' };

        // --- 1. 场景渲染引擎 (SceneController) ---
        class SceneController {
            constructor(container) {
                this.container = container;
                this.clock = new THREE.Clock();
                this.particles = [];
                this.dummy = new THREE.Object3D();
                this.rotationState = { x: 0, y: 0 };

                // 核心渲染组件
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x020210);
                this.scene.fog = new THREE.FogExp2(0x020210, 0.015);

                this.camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
                this.camera.position.z = 50;

                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(container.clientWidth, container.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                container.appendChild(this.renderer.domElement);

                // 后处理 (辉光效果)
                const renderScene = new RenderPass(this.scene, this.camera);
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.5, 0.4, 0.85);
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(renderScene);
                this.composer.addPass(bloomPass);

                this.initTree();
            }

            initTree() {
                // 光源
                this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
                const pLight = new THREE.PointLight(0x88ccff, 10, 100);
                pLight.position.set(0, 10, 20);
                this.scene.add(pLight);

                // 粒子树
                const geo = new THREE.IcosahedronGeometry(0.3, 0);
                const mat = new THREE.MeshStandardMaterial({ color: 0x88ccff, metalness: 0.2, roughness: 0.1 });
                this.instancedMesh = new THREE.InstancedMesh(geo, mat, 1500);
                this.scene.add(this.instancedMesh);

                for (let i = 0; i < 1500; i++) {
                    const t = Math.pow(Math.random(), 0.8);
                    const y = t * 24 - 12;
                    const r = (1 - t) * 8;
                    const angle = t * 40 * Math.PI + Math.random() * Math.PI;
                    const treePos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                    
                    const rS = 25 + Math.random() * 20;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const theta = Math.random() * Math.PI * 2;
                    const scatterPos = new THREE.Vector3(rS * Math.sin(phi) * Math.cos(theta), rS * Math.cos(phi), rS * Math.sin(phi) * Math.sin(theta));

                    this.particles.push({ treePos, scatterPos, currentPos: treePos.clone(), scale: 0.4 + Math.random() * 0.8 });
                }

                // 螺旋线
                const pts = [];
                for(let i=0; i<=200; i++) {
                    const t = i/200;
                    const angle = t * Math.PI * 12;
                    const r = (1-t) * 9.5;
                    pts.push(new THREE.Vector3(Math.cos(angle)*r, t*24-12, Math.sin(angle)*r));
                }
                const curve = new THREE.CatmullRomCurve3(pts);
                this.spiral = new THREE.Mesh(new THREE.TubeGeometry(curve, 200, 0.05, 8, false), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 }));
                this.scene.add(this.spiral);
            }

            animate(mode, gm) {
                const dt = this.clock.getDelta();
                
                // 相机跟随模式切换
                const targetZ = mode === InteractionMode.SCATTER ? 85 : 50;
                this.camera.position.z = THREE.MathUtils.lerp(this.camera.position.z, targetZ, 0.05);

                // 手势控制旋转
                if (mode === InteractionMode.SCATTER && gm.isHandDetected()) {
                    const hP = gm.getHandPosition();
                    this.rotationState.y = THREE.MathUtils.lerp(this.rotationState.y, hP.x * Math.PI, 0.1);
                    this.rotationState.x = THREE.MathUtils.lerp(this.rotationState.x, hP.y * Math.PI * 0.3, 0.1);
                } else {
                    this.rotationState.y += 0.5 * dt;
                    this.rotationState.x = THREE.MathUtils.lerp(this.rotationState.x, 0, 0.05);
                }
                
                this.instancedMesh.rotation.set(this.rotationState.x, this.rotationState.y, 0);
                this.spiral.rotation.set(this.rotationState.x, this.rotationState.y, 0);

                // 粒子过渡动画
                this.particles.forEach((p, i) => {
                    const target = mode === InteractionMode.SCATTER ? p.scatterPos : p.treePos;
                    p.currentPos.lerp(target, 0.08);
                    this.dummy.position.copy(p.currentPos);
                    this.dummy.scale.setScalar(p.scale);
                    this.dummy.updateMatrix();
                    this.instancedMesh.setMatrixAt(i, this.dummy.matrix);
                });

                this.instancedMesh.instanceMatrix.needsUpdate = true;
                this.composer.render();
            }

            resize() {
                this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
                this.composer.setSize(this.container.clientWidth, this.container.clientHeight);
            }
        }

        // --- 2. 手势识别 Hook ---
        const useMediaPipe = ({ videoRef, canvasRef, onGestureChange, onLoaded }) => {
            const landmarkerRef = useRef(null);
            const handPositionRef = useRef({ x: 0, y: 0 });
            const isHandDetectedRef = useRef(false);

            useEffect(() => {
                const init = async () => {
                    try {
                        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
                        landmarkerRef.current = await HandLandmarker.createFromOptions(vision, {
                            baseOptions: { 
                                modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                                delegate: "GPU" 
                            },
                            runningMode: "VIDEO", numHands: 1
                        });

                        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        if (videoRef.current) {
                            videoRef.current.srcObject = stream;
                            videoRef.current.onloadeddata = () => {
                                canvasRef.current.width = videoRef.current.videoWidth;
                                canvasRef.current.height = videoRef.current.videoHeight;
                                onLoaded();
                                requestAnimationFrame(loop);
                            };
                        }
                    } catch (e) { console.error(e); }
                };

                const loop = () => {
                    if (videoRef.current && landmarkerRef.current) {
                        const results = landmarkerRef.current.detectForVideo(videoRef.current, performance.now());
                        const ctx = canvasRef.current.getContext('2d');
                        ctx.save();
                        ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                        ctx.drawImage(videoRef.current, 0, 0, canvasRef.current.width, canvasRef.current.height);

                        if (results.landmarks && results.landmarks[0]) {
                            isHandDetectedRef.current = true;
                            const lm = results.landmarks[0];
                            new DrawingUtils(ctx).drawLandmarks(lm, { color: '#00ffff', radius: 2 });
                            
                            const wrist = lm[0];
                            const middle = lm[9];
                            const scale = Math.max(0.01, Math.hypot(wrist.x - middle.x, wrist.y - middle.y));
                            const pinch = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y) / scale;
                            
                            let tipAvg = 0;
                            [8, 12, 16, 20].forEach(i => tipAvg += Math.hypot(lm[i].x - middle.x, lm[i].y - middle.y));
                            const openness = (tipAvg / 4) / scale;

                            handPositionRef.current = { x: (lm[9].x - 0.5) * 2, y: (lm[9].y - 0.5) * 2 };

                            if (openness > 1.8) onGestureChange(InteractionMode.SCATTER, true);
                            else if (pinch < 0.6) onGestureChange(InteractionMode.FOCUS, true);
                            else if (openness < 1.0) onGestureChange(InteractionMode.TREE, true);
                        } else {
                            isHandDetectedRef.current = false;
                            onGestureChange(InteractionMode.TREE, false);
                        }
                        ctx.restore();
                    }
                    requestAnimationFrame(loop);
                };

                init();
            }, []);

            return { gestureManager: { isHandDetected: () => isHandDetectedRef.current, getHandPosition: () => handPositionRef.current } };
        };

        // --- 3. React 主应用 ---
        const App = () => {
            const [isLoading, setIsLoading] = useState(true);
            const [mode, setMode] = useState(InteractionMode.TREE);
            const [handDetected, setHandDetected] = useState(false);
            
            const vRef = useRef();
            const cRef = useRef();
            const containerRef = useRef();
            const sceneRef = useRef();

            const { gestureManager } = useMediaPipe({
                videoRef: vRef, canvasRef: cRef,
                onGestureChange: (m, d) => { setMode(m); setHandDetected(d); },
                onLoaded: () => {} 
            });

            useEffect(() => {
                if (containerRef.current && !sceneRef.current) {
                    sceneRef.current = new SceneController(containerRef.current);
                    setIsLoading(false);
                    
                    const animate = () => {
                        sceneRef.current.animate(mode, gestureManager);
                        requestAnimationFrame(animate);
                    };
                    animate();

                    const handleResize = () => sceneRef.current.resize();
                    window.addEventListener('resize', handleResize);
                    return () => window.removeEventListener('resize', handleResize);
                }
            }, [mode]); // 监听 mode 变化确保同步

            return (
                <div className="relative w-screen h-screen bg-[#020210] overflow-hidden">
                    {isLoading && (
                        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-[#020210]">
                            <div className="spinner w-12 h-12 border-4 border-cyan-500 border-t-transparent rounded-full"></div>
                            <p className="mt-4 text-cyan-400 font-['Cinzel'] tracking-widest">LOADING WINTER MAGIC...</p>
                        </div>
                    )}
                    
                    <div ref={containerRef} className="w-full h-full" />

                    <div className="absolute top-10 w-full text-center pointer-events-none z-10">
                        <h1 className="text-6xl md:text-8xl font-great-vibes text-glow bg-gradient-to-b from-white to-cyan-300 bg-clip-text text-transparent">Frozen Wonderland</h1>
                        <p className="text-cyan-400 mt-4 tracking-[0.4em] uppercase text-sm font-['Cinzel']">
                            {handDetected ? `Status: ${mode}` : "Raise Hand to Activate"}
                        </p>
                    </div>

                    <div className="absolute bottom-10 right-10 w-48 h-36 bg-black/40 border border-cyan-500/30 rounded-lg overflow-hidden backdrop-blur-md">
                        <video ref={vRef} className="hidden" playsInline muted></video>
                        <canvas ref={cRef} id="preview-canvas" className="w-full h-full object-cover"></canvas>
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
