<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frozen Wonderland - Particle Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/@babel/standalone@7.24.0/babel.min.js"></script>

    <style>
      body { background-color: #020210; margin: 0; overflow: hidden; }
      .spinner { animation: spin 1s linear infinite; }
      @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
      #preview-container { z-index: 999 !important; }
    </style>

    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.3.1",
        "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
        "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/+esm"
      }
    }
    </script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useEffect } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        const InteractionMode = { TREE: 'TREE', SCATTER: 'SCATTER', FOCUS: 'FOCUS' };

        const App = () => {
            const [isLoading, setIsLoading] = useState(true);
            const [mode, setMode] = useState(InteractionMode.TREE);
            const [handDetected, setHandDetected] = useState(false);
            
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const handLandmarkerRef = useRef(null);
            const isInitializing = useRef(false);
            const particlesRef = useRef([]);
            const dummy = new THREE.Object3D();

            // 初始化 MediaPipe 手势识别
            const initMediaPipe = async () => {
                if (isInitializing.current || handLandmarkerRef.current) return;
                isInitializing.current = true;

                try {
                    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.9/wasm");
                    handLandmarkerRef.current = await HandLandmarker.createFromOptions(vision, {
                        baseOptions: {
                            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                            delegate: "GPU"
                        },
                        runningMode: "VIDEO",
                        numHands: 1
                    });

                    const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                    if (videoRef.current) {
                        videoRef.current.srcObject = stream;
                        videoRef.current.onloadedmetadata = () => {
                            videoRef.current.play();
                            canvasRef.current.width = videoRef.current.videoWidth;
                            canvasRef.current.height = videoRef.current.videoHeight;
                            setIsLoading(false);
                            requestAnimationFrame(predictionLoop);
                        };
                    }
                } catch (e) {
                    console.error("MediaPipe Error:", e);
                }
            };

            const predictionLoop = () => {
                const video = videoRef.current;
                const canvas = canvasRef.current;
                const landmarker = handLandmarkerRef.current;

                if (video && canvas && landmarker && video.readyState >= 2) {
                    const results = landmarker.detectForVideo(video, performance.now());
                    const ctx = canvas.getContext('2d');
                    
                    ctx.save();
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.scale(-1, 1);
                    ctx.translate(-canvas.width, 0);
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                    if (results.landmarks && results.landmarks.length > 0) {
                        setHandDetected(true);
                        const lm = results.landmarks[0];
                        new DrawingUtils(ctx).drawLandmarks(lm, { color: '#00ffff', radius: 2 });
                        
                        // 判定手势
                        const wrist = lm[0];
                        const middleTip = lm[12];
                        const thumbTip = lm[4];
                        const indexTip = lm[8];

                        const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                        const handOpenDist = Math.hypot(middleTip.y - wrist.y);

                        if (pinchDist < 0.04) setMode(InteractionMode.FOCUS);
                        else if (handOpenDist > 0.4) setMode(InteractionMode.SCATTER);
                        else setMode(InteractionMode.TREE);
                    } else {
                        setHandDetected(false);
                        setMode(InteractionMode.TREE);
                    }
                    ctx.restore();
                }
                requestAnimationFrame(predictionLoop);
            };

            // 初始化华丽的粒子圣诞树
            useEffect(() => {
                if (!containerRef.current) return;
                
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                containerRef.current.appendChild(renderer.domElement);

                // 创建粒子群
                const particleCount = 2000;
                const geometry = new THREE.IcosahedronGeometry(0.1, 0);
                const material = new THREE.MeshPhongMaterial({ color: 0x88ccff, emissive: 0x112244 });
                const instancedMesh = new THREE.InstancedMesh(geometry, material, particleCount);
                
                const particles = [];
                for (let i = 0; i < particleCount; i++) {
                    const t = Math.random();
                    const angle = t * Math.PI * 40;
                    const radius = (1 - t) * 8;
                    const y = t * 24 - 12;

                    // 树形态位置
                    const treePos = new THREE.Vector3(Math.cos(angle) * radius, y, Math.sin(angle) * radius);
                    // 扩散形态位置
                    const scatterPos = new THREE.Vector3().copy(treePos).multiplyScalar(3 + Math.random() * 2);
                    
                    particles.push({ 
                        current: treePos.clone(), 
                        tree: treePos, 
                        scatter: scatterPos,
                        speed: 0.05 + Math.random() * 0.05 
                    });
                }
                particlesRef.current = particles;
                scene.add(instancedMesh);

                const light = new THREE.PointLight(0x00ffff, 2, 100);
                light.position.set(0, 10, 10);
                scene.add(light, new THREE.AmbientLight(0x202020));
                camera.position.set(0, 0, 50);

                let currentMode = InteractionMode.TREE;
                
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // 平滑过渡粒子位置
                    particlesRef.current.forEach((p, i) => {
                        const target = mode === InteractionMode.SCATTER ? p.scatter : p.tree;
                        p.current.lerp(target, 0.05);
                        
                        dummy.position.copy(p.current);
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(i, dummy.matrix);
                    });
                    
                    instancedMesh.instanceMatrix.needsUpdate = true;
                    instancedMesh.rotation.y += 0.005;
                    renderer.render(scene, camera);
                };
                animate();
                
                initMediaPipe();

                return () => {
                    renderer.dispose();
                    if (containerRef.current) containerRef.current.innerHTML = '';
                };
            }, [mode]); // 当 mode 改变时更新目标

            return (
                <div className="relative w-screen h-screen bg-black">
                    {isLoading && (
                        <div className="absolute inset-0 z-[100] bg-[#020210] flex flex-col items-center justify-center">
                            <div className="spinner w-12 h-12 border-4 border-cyan-500 border-t-transparent rounded-full"></div>
                            <p className="mt-4 text-cyan-400 tracking-widest uppercase">Initializing Wonderland...</p>
                        </div>
                    )}

                    <div ref={containerRef} className="w-full h-full" />

                    <div className="absolute top-10 w-full text-center pointer-events-none z-10">
                        <h1 className="text-6xl font-['Great_Vibes'] text-cyan-100 drop-shadow-[0_0_20px_rgba(0,255,255,0.5)]">Frozen Tree</h1>
                        <p className="text-cyan-400 mt-2 uppercase tracking-[0.3em] font-['Cinzel']">
                            {handDetected ? `Status: ${mode}` : "Raise your hand"}
                        </p>
                    </div>

                    <div id="preview-container" className="absolute bottom-5 right-5 w-48 h-36 border-2 border-cyan-500 rounded-lg overflow-hidden bg-black">
                        <video ref={videoRef} className="hidden" playsInline muted />
                        <canvas ref={canvasRef} className="w-full h-full object-cover scale-x-[-1]" />
                    </div>
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
